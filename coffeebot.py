import zulip
import json
import requests
import random
import os
import socket
import traceback

AVG_READ = 350 # AnalogIn read with no light + 100
LIGHT_ON_READ = 500 # AnalogIn read with light

class Coffeebot():
    ''' Coffeebot connects with an arduino. The arduino is running
        a script that passes the values of Analog Pin 0 to Coffeebot.
        Coffeebot reads the values, and posts to zulip when the values
        indicate the light on the coffee pot has turned on or off,
        indicating that the coffee is brewing or done.
    '''
    def __init__(self):
        self.zulip_username = 'CoffeeBot-bot@students.hackerschool.com'
        self.zulip_api_key = 'x9B2OV00fgbgT5BOcXlJawDNv7OSfQAt'
        self.zulip_client = zulip.Client(email=self.zulip_username,
                            api_key=self.zulip_api_key)
        self.connected = False
        self.host = '' #remote host
        self.port = 6880
        self.server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.arduino = self.server()
        self.buff = ''
        self.previous = 0


    def subscribe_to_stream(self):
        ''' subscribe to zulip stream '455 Broadway'
        '''
        self.zulip_client.add_subscriptions([
            {'name': u'bot-test'},
            {'name': u'Victory'},
            {'name': u'455 Broadway'}
            ])


    def server(self):
        ''' Open server socket
        '''
        self.server_sock.bind((self.host, self.port))
        self.server_sock.listen(1)
        while self.connected == False:
            (arduino, address) = self.server_sock.accept()
            print "Connected!"
            self.connected == True
            return arduino


    def message_iter(self):
        ''' Generator adds bytes passed by arduino to a buffer
            and yields each message individually.
        '''
        while True:
            chunk = self.arduino.recv(2048)
            if chunk == b'':
                self.connected = False
                raise RuntimeError("socket connection broken")
            else:
                self.buff += chunk
                while self.buff.find('\n') != -1:
                    msg, self.buff = self.buff.split('\n', 1)
                    yield msg


    def check_message(self, value):
        ''' Checks if message value has changed since the last 
            reading and calls send_message when appropriate.
            Updates self.previous
        '''
        value = int(value)
        if value < AVG_READ and self.previous >  LIGHT_ON_READ:
            self.send_message("Coffee is ready!")
            self.send_message("gif me coffee")
        elif value > LIGHT_ON_READ and self.previous < AVG_READ:
            self.send_message("Coffee is brewing!")
            self.send_message("gif me coffee")
        self.previous = value
        

    def send_message(self, msg):
        '''    
            Posts message to bot-test stream on zulip.
        '''
        self.zulip_client.send_message({
            "type": "stream",
            "subject": "CoffeeCoffeeCoffeeCoffee!",
            "to": "bot-test",
            "content": msg
        })


    def main(self):
        ''' Iterates over values generated by message_iter.
        '''
        for msg in self.message_iter():
            self.check_message(msg)     
        

    def cleanup(self):
        ''' Closes all open sockets when program is interrupted
        '''
        try:
            self.server_sock.shutdown(socket.SHUT_RDWR)
        except Exception as e:
            pass
        try:
            self.arduino.shutdown(socket.SHUT_RDWR)
        except Exception as e:
            pass


''' Attempts to restart bot in case of interruptions
'''
while True:
    try:
        bot = Coffeebot()
        bot.main()
    except KeyboardInterrupt as e:
        bot.cleanup()
        raise e
    except Exception as e:
        bot.cleanup()
        print("Some kind of error occurred while running the bot:")
        traceback.print_exc()
